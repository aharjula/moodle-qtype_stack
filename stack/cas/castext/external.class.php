<?php
// This file is part of Stack - http://stack.bham.ac.uk/
//
// Stack is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Stack is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Stack.  If not, see <http://www.gnu.org/licenses/>.

/**
 * @copyright  2013 Aalto University
 * @copyright  2012 University of Birmingham
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
require_once(__DIR__ . '/../casstring.class.php');
require_once('external/latex.class.php');

class stack_cas_castext_external extends stack_cas_castext_block {

    private $handler = null;

    public function extract_attributes(&$tobeevaluatedcassession, $conditionstack = null) {
        $type = $this->get_node()->get_parameter('type', null);
        switch ($type) {
            case 'latex':
                $this->handler = new stack_cas_castext_external_latex();
                break;
        }
        if ($this->handler !== null) {
            $this->handler->extract_attributes($this->get_node(), $tobeevaluatedcassession, $conditionstack);
        }
    }

    public function content_evaluation_context($conditionstack = array()) {
        return $conditionstack;
    }

    public function process_content($evaluatedcassession, $conditionstack = null) {
        global $CFG;

        // Check if the contents have been fully evaluated.
        $this->get_node()->normalize();
        if ($this->get_node()->firstchild->nextsibling !== null) {
            return true;
        }

        // Give the contents a name, somewhat unique name is better so dual hash to avoid collissions.
        $fullcontent = $this->get_node()->firstchild->to_string();
        $name = md5($fullcontent).sha1($fullcontent);

        // If the handler is still null note it somehow.
        if ($this->handler === null) {
            $this->get_node()->convert_to_text("<pre>UNKNOWN EXTERNAL-TYPE\n".$this->handler->get_replacement_text()."</pre>");
            return false;
        }

        // Configure the handler.
        $this->handler->set_name($name);
        $this->handler->set_attributes($evaluatedcassession);

        // Check if all the files generated by the handler are in cache, if so use them.
        $generated = $this->handler->get_generated_files();
        $allready = true;
        foreach ($generated as $file) {
            if (!file_exists($file)) {
                $allready = false;
            }
        }
        if ($allready) {
            $this->get_node()->convert_to_text($this->handler->get_replacement_text());
            return false;
        }

        // Extract work files for the handler, by splitting the block contents at "### FILE: filename ###".
        $files = array();
        foreach (explode('### FILE: ', $fullcontent) as $split) {
            if (count($files) == 0) {
                $files['__SOURCE_CODE__'] = $split;
            } else {
                $key = trim(substr($split, 0, strpos($split, '###')));
                $files[$key] = substr($split, strpos($split, '###') + 3);
            }
        }

        // Map those files to actual filenames as well as common keys for the handler to identify.
        $labelmap = array();
        $i = 0;
        $tempdir = sys_get_temp_dir() . "/$name";
        mkdir($tempdir);
        foreach (array_keys($files) as $key) {
            $i++;
            if ($key == '__SOURCE_CODE__') {
                $label = $name.$this->handler->get_source_file_extension();
            } else {
                $label = $name.'-'.$i;
                if (strpos($key, '.') !== false) {
                    $possiblefileextension = substr($key, strpos($key, '.'));
                    $okextension = true;
                    for ($j = 0; $j < strlen($possiblefileextension); $j++) {
                        $c = substr($possiblefileextension, $j, 1);
                        if (!($c == '.' || ctype_alnum($c))) {
                            $okextension = false;
                        }
                    }
                    if ($okextension) {
                        $label .= $possiblefileextension;
                    }
                }
            }
            $label = "$tempdir/". $label;
            $labelmap[$key] = $label;
            foreach (array_keys($files) as $k) {
                $files[$k] = str_replace($key, $label, $files[$k]);
            }
        }

        // Write the files out.
        foreach (array_keys($files) as $key) {
            file_put_contents($labelmap[$key], $files[$key]);
        }

        // Make the handler work on those file.
        $this->handler->process($labelmap);

        // Destroy the files and the work dir.
        foreach ($labelmap as $key => $file) {
            unlink($file);
        }
        rmdir($tempdir);

        // Use the files generated to replace the nodes contents.
        $this->get_node()->convert_to_text($this->handler->get_replacement_text());
        return false;
    }

    public function validate_extract_attributes() {
        $type = $this->get_node()->get_parameter('type', null);
        switch ($type) {
            case 'latex':
                $this->handler = new stack_cas_castext_external_latex();
                break;
            default:
                return array();
        }

        return $this->handler->validate_extract_attributes();
    }

    public function validate(&$errors='') {
        $valid = parent::validate($errors);
        $config = stack_utils::get_config();
        if ($this->get_node()->get_parameter('type', null) == 'latex' && $config->externalblocklatex == '0') {
            $errors[] = stack_string('stackBlock_eternalLatexNotEnabled').' ';
            $valid = false;
        }

        if ($this->get_node()->get_parameter('type', null) == null || $this->get_node()->get_parameter('type', null) == '' ||
                $this->handler == null) {
            $errors[] = stack_string('stackBlock_eternalMustHaveType').' ';
        }

        return $valid;
    }
}

abstract class stack_cas_castext_external_handler {
    public $name;

    /**
     * Should the handler need attributes to be evaluated in the CAS this is basically the same as the block-interfaces.
     */
    public abstract function extract_attributes($node, &$tobeevaluatedcassession, $conditionstack);

    /**
     * Same thing as blocks, if you need to use CAS on the attributes you also need to declare them for validation.
     */
    public abstract function validate_extract_attributes();

    /**
     * Name for this handler instance, used for naming of files.
     */
    public function set_name($name) {
        $this->name = $name;
    }

    /**
     * A CAS session with the attributes that the handler requested to be evaluated.
     */
    public abstract function set_attributes($evaluatedcassession);

    /**
     * The handler must list all the files generated by the handler and it must do it even before the content processing is called.
     * Should there be uncertainty on what files will be generated the handler should generate some markker file so that it can
     * identify when all files have been generated and just give it here, as the primary point of this function is to check for the
     * existence of these files and skip the process stepp if they are present.
     */
    public abstract function get_generated_files();

    /**
     * The contents of the external-block are stored in a randomly named file, should the handlers external processing tools
     * require a specific extension you may ask for it here. Should there be multiple files the extensions for the additional
     * files comes from the file labels.
     */
    public function get_source_file_extension() {
        return ".txt";
    }

    /**
     * Generate the files required by this handler based on the files provided as the $labelmap. The map will contain
     * a '__SOURCE_CODE__' key that points to the file with the primary content of the block. Other keys may exists if
     * the block contains them. The processing of the handler should be done in the directory of the '__SOURCE_CODE__'-file
     * or in other temporary place and the generated files should be stored under $dataroot/stack.
     */
    public abstract function process($labelmap);

    /**
     * Return an img-tag or whatever else representing the contents of this block.
     */
    public abstract function get_replacement_text();
}